<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Dial Two-Level Buckets Visualization</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="visualPages.css">
  <style>
    :root {
      color-scheme: light dark;
      --bg: #eff2fb;
      --panel: #ffffff;
      --graph-panel: #f8fafc;
      --text: #1e293b;
      --muted: #64748b;
      --accent: #2563eb;
      --accent-strong: #f97316;
      --success: #22c55e;
      --danger: #dc2626;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Segoe UI", "PingFang SC", sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    header {
      background: #173f5f;
      color: #fff;
      padding: 1.2rem 2rem;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.12);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1.5rem;
    }

    header h1 {
      margin: 0;
      font-size: 1.6rem;
    }

    .school-badge {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.4rem 0.9rem 0.4rem 0.4rem;
      background: rgba(255, 255, 255, 0.08);
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.25);
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.15);
      backdrop-filter: blur(4px);
    }

    .school-logo {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      display: block;
      pointer-events: none;
    }

    .school-badge-text {
      display: flex;
      flex-direction: column;
      line-height: 1.2;
    }

    .school-name-cn {
      font-weight: 600;
      font-size: 0.95rem;
    }

    .school-name-en {
      font-size: 0.75rem;
      opacity: 0.85;
      letter-spacing: 0.05em;
    }

    button {
      padding: 0.6rem 0.8rem;
      font-size: 0.95rem;
      border: none;
      border-radius: 12px;
      background: var(--accent);
      color: #fff;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    button:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
    }

    button:active:not(:disabled) {
      transform: translateY(0);
    }

    button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
      transform: none;
    }

    .controls {
      display: flex;
      flex-direction: column;
      gap: 0.8rem;
    }

    .control-buttons {
      display: flex;
      gap: 0.5rem;
      width: 100%;
    }

    .control-buttons button {
      flex: 1 1 0;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.3rem;
    }

    .controls .reset-btn {
      background: #dc2626;
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.3rem;
    }

    #playPauseBtn.playing {
      background: #e74c3c;
    }

    #speedSlider {
      -webkit-appearance: none;
      appearance: none;
      height: 6px;
      border-radius: 3px;
      background: #e0e0e0;
      outline: none;
    }

    #speedSlider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    #speedSlider::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
      border: none;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    main {
      flex: 1;
      display: flex;
      padding: 0 1.5rem 2rem;
    }

    .layout-row {
      display: flex;
      gap: 1.5rem;
      width: 100%;
      align-items: flex-start;
      flex-wrap: nowrap;
    }

    .graph-panel {
      flex: 2 1 540px;
      min-width: 520px;
      background: var(--panel);
      border-radius: 18px;
      padding: 1.5rem;
      box-shadow: 0 20px 50px rgba(15, 23, 42, 0.08);
    }

    .graph-panel h2,
    .bucket-panel h2 {
      margin: 0 0 0.8rem;
      font-size: 1.1rem;
      letter-spacing: 0.05em;
      color: var(--muted);
      text-transform: uppercase;
    }

    #graphSvg {
      width: 100%;
      height: 480px;
      background: var(--graph-panel);
      border-radius: 14px;
    }

    .bucket-panel {
      background: var(--panel);
      border-radius: 18px;
      padding: 1.2rem 1.4rem;
      box-shadow: 0 20px 50px rgba(15, 23, 42, 0.08);
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .bucket-mode-toggle {
      display: flex;
      align-items: center;
      gap: 0.6rem;
      font-size: 0.9rem;
      color: var(--muted);
    }

    .bucket-mode-toggle select {
      flex: 1;
      padding: 0.35rem 0.5rem;
      border-radius: 10px;
      border: 1px solid #d1d9e6;
      background: #fff;
      color: var(--text);
    }

    .super-buckets {
      display: flex;
      gap: 0.8rem;
      overflow-x: auto;
      padding-bottom: 0.3rem;
    }

    .super-card {
      min-width: 120px;
      border-radius: 14px;
      padding: 0.8rem;
      background: #f8fafc;
      border: 2px solid transparent;
      transition: transform 0.2s, border 0.2s;
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
    }

    .super-card.active {
      border-color: var(--accent);
      transform: translateY(-4px);
      box-shadow: 0 12px 24px rgba(37, 99, 235, 0.2);
    }

    .super-card.scanning {
      border-color: var(--accent-strong);
      background: #fff7ed;
    }

    .super-card.scan-found {
      border-color: var(--success);
      background: #ecfdf5;
      box-shadow: 0 12px 24px rgba(34, 197, 94, 0.25);
    }

    .super-card.super-min {
      border-color: var(--accent-strong);
    }

    .super-title {
      font-weight: 700;
      color: var(--text);
    }

    .super-status {
      font-size: 0.9rem;
      color: var(--muted);
    }

    .super-range {
      white-space: nowrap;
    }

    .bucket-detail {
      background: #f8fafc;
      border-radius: 16px;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
    }

    .bucket-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 0.8rem;
    }

    .bucket-cell {
      border-radius: 12px;
      border: 2px solid transparent;
      background: #fff;
      padding: 0.5rem 0.7rem;
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
      transition: border 0.2s, transform 0.2s;
    }

    .bucket-cell.min {
      border-color: var(--accent-strong);
      transform: translateY(-2px);
      box-shadow: 0 10px 18px rgba(249, 115, 22, 0.2);
    }

    .bucket-cell.focus {
      border-color: #a5b4fc;
      box-shadow: 0 6px 12px rgba(129, 140, 248, 0.25);
    }

    .bucket-cell.scanning {
      border-color: var(--accent-strong);
      background: #fff7ed;
    }

    .bucket-cell.scan-found {
      border-color: var(--success);
      background: #ecfdf5;
    }

    .bucket-index {
      font-weight: 600;
      color: var(--muted);
    }

    .bucket-content {
      font-size: 0.95rem;
      color: var(--text);
    }

    .status-board {
      padding: 0.9rem 1rem;
      border-radius: 14px;
      background: #fff6ed;
      border: 1px solid #fed7aa;
      line-height: 1.6;
      font-size: 0.95rem;
    }

    .status-board strong {
      color: var(--accent);
    }

    .node-label {
      font-weight: 700;
      pointer-events: none;
    }

    .node circle {
      transition: all 0.3s ease;
    }

    .node:hover circle {
      r: 32;
      filter: brightness(1.08);
    }

    .dist-label {
      pointer-events: none;
      font-size: 0.85rem;
      fill: var(--muted);
    }

    @media (max-width: 1200px) {
      .layout-row {
        flex-direction: column;
      }
      .graph-panel,
      .bucket-panel {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Dial's Algorithm ‚Äî Two-Level Buckets (Super Bucket + Bucket)</h1>
    <div class="school-badge">
      <img src="bit.png" alt="Beijing Institute of Technology Emblem" class="school-logo">
      <div class="school-badge-text">
        <span class="school-name-cn">Âåó‰∫¨ÁêÜÂ∑•Â§ßÂ≠¶</span>
        <span class="school-name-en">Beijing Institute of Technology</span>
      </div>
    </div>
  </header>

  <main>
    <div class="layout-row">
      <div style="flex:2 1 540px;min-width:520px;display:flex;flex-direction:column;gap:1rem;">
        <section class="graph-panel">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:1rem;">
            <h2 style="margin:0;">Graph View (Draggable Nodes)</h2>
            <div class="graph-controls" style="display:flex;gap:0.5rem;align-items:center;">
              <label style="font-size:0.9rem;">Nodes:</label>
              <input type="number" id="nodeCountInput" value="7" min="2" max="15" style="width:60px;padding:0.3rem;border:1px solid #ccc;border-radius:6px;">
              <label style="font-size:0.9rem;">Edges:</label>
              <input type="number" id="edgeCountInput" value="11" min="1" max="50" style="width:60px;padding:0.3rem;border:1px solid #ccc;border-radius:6px;">
              <button id="generateGraphBtn" style="padding:0.4rem 0.8rem;font-size:0.9rem;background:#22c55e;color:#fff;border:none;border-radius:6px;cursor:pointer;">Generate Random Graph</button>
            </div>
          </div>
          <svg id="graphSvg" viewBox="0 0 760 520">
            <defs>
              <marker id="arrow" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
                <path d="M 0 0 L 10 5 L 0 10 z" fill="#94a3b8"></path>
              </marker>
            </defs>
          </svg>
        </section>

        <div style="display:flex;gap:1rem;flex-wrap:wrap;">
          <section class="controls" style="flex:1 1 300px;background:var(--panel);border-radius:16px;box-shadow:0 10px 30px rgba(15,23,42,0.08);padding:1.5rem;">
            <h3 style="margin:0 0 1rem;font-size:1rem;">Control Panel</h3>
            <div class="control-buttons">
              <button id="prevBtn" style="flex:1 1 90px;">‚èÆ Previous</button>
              <button id="nextBtn" style="flex:1 1 90px;">Next ‚è≠</button>
              <button id="playPauseBtn" style="flex:1 1 90px;background:#22c55e;">‚ñ∂ Play</button>
            </div>
            <div style="margin-top:0.5rem;display:flex;align-items:center;gap:0.5rem;">
              <label style="font-size:0.85rem;flex-shrink:0;">Speed:</label>
              <input type="range" id="speedSlider" min="100" max="2000" value="800" step="100" style="flex:1;">
              <span id="speedValue" style="font-size:0.85rem;min-width:40px;text-align:right;">0.8s</span>
            </div>
            <button id="resetBtn" class="reset-btn">üîÑ Reset</button>
          </section>

          <section class="stats-panel" style="flex:1 1 200px;background:var(--panel);border-radius:16px;box-shadow:0 10px 30px rgba(15,23,42,0.08);padding:1.5rem;">
            <h3 style="margin:0 0 0.8rem;font-size:1rem;">Statistics</h3>
            <div id="statsInfo" style="font-size:0.9rem;line-height:1.8;color:var(--muted);"></div>
          </section>

          <section class="legend-panel" style="flex:1 1 200px;background:var(--panel);border-radius:16px;box-shadow:0 10px 30px rgba(15,23,42,0.08);padding:1.5rem;">
            <h3 style="margin:0 0 0.8rem;font-size:1rem;">Legend</h3>
            <div style="font-size:0.85rem;line-height:2;">
              <div style="display:flex;align-items:center;gap:0.5rem;">
                <div style="width:20px;height:20px;border-radius:50%;background:#2563eb;border:2px solid #0f172a;"></div>
                <span>Unvisited Node</span>
              </div>
              <div style="display:flex;align-items:center;gap:0.5rem;">
                <div style="width:20px;height:20px;border-radius:50%;background:#f97316;border:3px solid #0f172a;"></div>
                <span>Current Node</span>
              </div>
              <div style="display:flex;align-items:center;gap:0.5rem;">
                <div style="width:20px;height:20px;border-radius:50%;background:#22c55e;border:2px solid #0f172a;"></div>
                <span>Settled Node</span>
              </div>
            </div>
            <div style="margin-top:1rem;padding-top:1rem;border-top:1px solid #e2e8f0;">
              <div style="font-size:0.85rem;line-height:1.8;">
                <div style="font-weight:600;margin-bottom:0.3rem;">Block Size Control:</div>
                <div style="display:flex;align-items:center;gap:0.5rem;">
                  <label style="font-size:0.85rem;">Block size b = <span id="blockSizeValue">5</span></label>
                  <input id="blockSizeRange" type="range" min="2" max="8" step="1" value="5" style="flex:1;">
                </div>
              </div>
            </div>
          </section>
        </div>
      </div>

      <aside class="bucket-panel" style="flex:1 1 360px;min-width:320px;">
        <h2 id="bucketTitle">Two-Level Bucket Structure (C = 16)</h2>
        <div class="bucket-mode-toggle">
          <label for="minBucketModeSelect">min_bucket Mode:</label>
          <select id="minBucketModeSelect">
            <option value="tracked">Track min bucket</option>
            <option value="scan">Sequential scan</option>
          </select>
        </div>
        <div class="super-buckets" id="superBucketContainer"></div>
        <div class="bucket-detail">
          <div id="bucketDetailTitle" style="font-weight:700; color:var(--text);">Lower buckets</div>
          <div class="bucket-grid" id="bucketGrid"></div>
        </div>
        <div class="status-board">
          <div id="stepCounter" style="font-weight:600;margin-bottom:0.5rem;"></div>
          <div style="width:100%;height:6px;background:#e0e0e0;border-radius:3px;margin-bottom:0.8rem;overflow:hidden;">
            <div id="progressBar" style="height:100%;background:linear-gradient(90deg, #2563eb, #22c55e);width:0%;transition:width 0.3s ease;"></div>
          </div>
          <div id="currentAction" style="font-weight:600;margin-top:0.2rem;color:var(--text);font-size:1rem;"></div>
          <p id="stepDescription" style="margin:0.5rem 0 0;line-height:1.6;"></p>
          <p id="minBucketLabel" style="margin:0.6rem 0 0;font-weight:600;color:var(--accent);"></p>
        </div>
      </aside>
    </div>
  </main>

  <script>
    /**
     * Dial's Algorithm Visualization - Two-Level Buckets
     * 
     * This file implements an interactive visualization of Dial's algorithm
     * for finding shortest paths in weighted graphs using a two-level bucket structure.
     * 
     * Features:
     * - Interactive graph with draggable nodes
     * - Step-by-step algorithm visualization
     * - Two-level bucket structure (super buckets + buckets)
     * - Adjustable block size parameter
     * - Play/Pause controls with speed adjustment
     * - Random graph generation
     * - Two visualization modes: tracked min_bucket or sequential scan
     * 
     * Algorithm: Dial's algorithm with two-level bucket optimization
     * Data Structure: 
     *   - Super buckets (blocks): Groups of buckets
     *   - Buckets: Individual buckets within blocks
     *   - Bucket index = distance % totalBuckets
     *   - Block index = floor(distance / blockSize)
     */

    /**
     * Calculate the maximum bucket index C for Dial's algorithm
     * C = max edge weight √ó (node count - 1)
     * 
     * This ensures all possible distances fit within the bucket array.
     * The two-level bucket structure organizes buckets into blocks for efficiency.
     * 
     * @returns {number} The calculated C value (minimum 16, maximum 200)
     */
    function calculateC() {
      if (graph.edges.length === 0) return 16;
      const maxEdgeWeight = Math.max(...graph.edges.map(e => e.weight));
      const maxPossibleDist = maxEdgeWeight * (graph.nodes.length - 1);
      return Math.min(Math.max(16, maxPossibleDist), 200);
    }
    // Algorithm parameters
    let C = 16; // Maximum bucket index, calculated dynamically
    let totalBuckets = C + 1; // Total number of buckets (0 to C)
    let blockSize = 5; // Number of buckets per super bucket (block)

    const blockSizeRange = document.getElementById('blockSizeRange');
    const blockSizeValue = document.getElementById('blockSizeValue');
    const stepCounterEl = document.getElementById('stepCounter');
    const currentActionEl = document.getElementById('currentAction');
    const stepDescriptionEl = document.getElementById('stepDescription');
    const minBucketLabelEl = document.getElementById('minBucketLabel');
    const minBucketModeSelect = document.getElementById('minBucketModeSelect');
    const superBucketContainer = document.getElementById('superBucketContainer');
    const bucketGrid = document.getElementById('bucketGrid');
    const bucketDetailTitle = document.getElementById('bucketDetailTitle');
    const bucketTitle = document.getElementById('bucketTitle');
    const progressBar = document.getElementById('progressBar');
    const statsInfo = document.getElementById('statsInfo');

    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const resetBtn = document.getElementById('resetBtn');
    const playPauseBtn = document.getElementById('playPauseBtn');
    const speedSlider = document.getElementById('speedSlider');
    const speedValue = document.getElementById('speedValue');
    const generateGraphBtn = document.getElementById('generateGraphBtn');
    const nodeCountInput = document.getElementById('nodeCountInput');
    const edgeCountInput = document.getElementById('edgeCountInput');

    const svg = document.getElementById('graphSvg');
    let minBucketMode = minBucketModeSelect ? minBucketModeSelect.value : 'tracked';
    const SUPER_SCAN_BUDGET = 1600;
    const BUCKET_SCAN_BUDGET = 1200;
    const SCAN_MIN_DELAY = 60;
    const SCAN_MAX_DELAY = 220;

    let graph = {
      nodes: [
        { id: 1, label: '1', x: 80, y: 260 },
        { id: 2, label: '2', x: 220, y: 120 },
        { id: 3, label: '3', x: 220, y: 380 },
        { id: 4, label: '4', x: 360, y: 120 },
        { id: 5, label: '5', x: 360, y: 380 },
        { id: 6, label: '6', x: 520, y: 240 },
        { id: 7, label: '7', x: 680, y: 240 }
      ],
      edges: [
        { id: '1-2', from: 1, to: 2, weight: 3 },
        { id: '1-3', from: 1, to: 3, weight: 5 },
        { id: '2-4', from: 2, to: 4, weight: 4 },
        { id: '2-6', from: 2, to: 6, weight: 8 },
        { id: '3-5', from: 3, to: 5, weight: 6 },
        { id: '3-6', from: 3, to: 6, weight: 7 },
        { id: '4-6', from: 4, to: 6, weight: 3 },
        { id: '4-7', from: 4, to: 7, weight: 5 },
        { id: '5-6', from: 5, to: 6, weight: 4 },
        { id: '5-7', from: 5, to: 7, weight: 6 },
        { id: '6-7', from: 6, to: 7, weight: 2 }
      ]
    };

    /**
     * Generate a random undirected graph with specified node and edge counts
     * Ensures connectivity by first creating a spanning tree, then adding random edges
     * Uses force-directed layout to position nodes without overlap
     * 
     * @param {number} nodeCount - Number of nodes (2-15)
     * @param {number} edgeCount - Number of edges (must be at least nodeCount-1)
     * @returns {Object} Graph object with nodes and edges arrays
     */
    function generateRandomGraph(nodeCount, edgeCount) {
      const nodes = [];
      const edges = [];
      const edgeSet = new Set();
      
      const svgWidth = 760;
      const svgHeight = 520;
      const padding = 80;
      const minNodeDistance = 100;
      
      let nodePositions = [];
      
      if (nodeCount <= 6) {
        const centerX = svgWidth / 2;
        const centerY = svgHeight / 2;
        const minRadius = (minNodeDistance * nodeCount) / (2 * Math.PI);
        const maxRadius = Math.min(150, (Math.min(svgWidth, svgHeight) - 2 * padding) / 2);
        const radius = Math.max(minRadius, maxRadius * 0.7);
        for (let i = 1; i <= nodeCount; i++) {
          const angle = (2 * Math.PI * (i - 1)) / nodeCount - Math.PI / 2;
          const x = centerX + radius * Math.cos(angle);
          const y = centerY + radius * Math.sin(angle);
          nodePositions.push({ id: i, x: x, y: y });
        }
      } else if (nodeCount <= 10) {
        const centerX = svgWidth / 2;
        const centerY = svgHeight / 2;
        const maxRadius = Math.min(180, (Math.min(svgWidth, svgHeight) - 2 * padding) / 2);
        const outerCount = Math.ceil(nodeCount * 0.6);
        const innerCount = nodeCount - outerCount;
        const outerMinRadius = (minNodeDistance * outerCount) / (2 * Math.PI);
        const outerRadius = Math.max(outerMinRadius, maxRadius * 0.85);
        const innerMinRadius = Math.max(outerRadius * 0.4, (minNodeDistance * innerCount) / (2 * Math.PI));
        const innerRadius = Math.min(innerMinRadius, outerRadius - minNodeDistance * 0.6);
        
        for (let i = 0; i < outerCount; i++) {
          const angle = (2 * Math.PI * i) / outerCount - Math.PI / 2;
          const x = centerX + outerRadius * Math.cos(angle);
          const y = centerY + outerRadius * Math.sin(angle);
          nodePositions.push({ id: i + 1, x: x, y: y });
        }
        
        for (let i = 0; i < innerCount; i++) {
          const angle = (2 * Math.PI * i) / innerCount - Math.PI / 2 + (innerCount > 1 ? Math.PI / innerCount : 0);
          const x = centerX + innerRadius * Math.cos(angle);
          const y = centerY + innerRadius * Math.sin(angle);
          nodePositions.push({ id: outerCount + i + 1, x: x, y: y });
        }
      } else {
        const availableWidth = svgWidth - 2 * padding;
        const availableHeight = svgHeight - 2 * padding;
        const maxCols = Math.floor(availableWidth / minNodeDistance);
        const maxRows = Math.floor(availableHeight / minNodeDistance);
        const cols = Math.min(Math.ceil(Math.sqrt(nodeCount * 1.3)), maxCols);
        const rows = Math.min(Math.ceil(nodeCount / cols), maxRows);
        const cellWidth = availableWidth / Math.max(cols, 1);
        const cellHeight = availableHeight / Math.max(rows, 1);
        const actualCellWidth = Math.max(cellWidth, minNodeDistance * 1.1);
        const actualCellHeight = Math.max(cellHeight, minNodeDistance * 1.1);
        const totalWidth = actualCellWidth * cols;
        const totalHeight = actualCellHeight * rows;
        const startX = (svgWidth - totalWidth) / 2;
        const startY = (svgHeight - totalHeight) / 2;
        
        for (let i = 1; i <= nodeCount; i++) {
          const row = Math.floor((i - 1) / cols);
          const col = (i - 1) % cols;
          const offsetX = (Math.random() - 0.5) * actualCellWidth * 0.1;
          const offsetY = (Math.random() - 0.5) * actualCellHeight * 0.1;
          const x = startX + col * actualCellWidth + actualCellWidth / 2 + offsetX;
          const y = startY + row * actualCellHeight + actualCellHeight / 2 + offsetY;
          nodePositions.push({ id: i, x: x, y: y });
        }
      }
      
      for (let iter = 0; iter < 150; iter++) {
        for (let i = 0; i < nodePositions.length; i++) {
          let fx = 0, fy = 0;
          for (let j = 0; j < nodePositions.length; j++) {
            if (i === j) continue;
            const dx = nodePositions[i].x - nodePositions[j].x;
            const dy = nodePositions[i].y - nodePositions[j].y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < 0.1) {
              const angle = Math.random() * 2 * Math.PI;
              fx += Math.cos(angle) * minNodeDistance;
              fy += Math.sin(angle) * minNodeDistance;
            } else if (dist < minNodeDistance) {
              const force = (minNodeDistance - dist) / dist * 2.0;
              fx += (dx / dist) * force;
              fy += (dy / dist) * force;
            } else if (dist < minNodeDistance * 1.2) {
              const force = (minNodeDistance * 1.2 - dist) / (minNodeDistance * 0.2) * 0.3;
              fx += (dx / dist) * force;
              fy += (dy / dist) * force;
            }
          }
          
          const boundaryPadding = padding + 20;
          if (nodePositions[i].x < boundaryPadding) {
            fx += (boundaryPadding - nodePositions[i].x) * 0.1;
          }
          if (nodePositions[i].x > svgWidth - boundaryPadding) {
            fx -= (nodePositions[i].x - (svgWidth - boundaryPadding)) * 0.1;
          }
          if (nodePositions[i].y < boundaryPadding) {
            fy += (boundaryPadding - nodePositions[i].y) * 0.1;
          }
          if (nodePositions[i].y > svgHeight - boundaryPadding) {
            fy -= (nodePositions[i].y - (svgHeight - boundaryPadding)) * 0.1;
          }
          
          const damping = 0.8;
          const maxMove = Math.max(10, minNodeDistance * 0.1);
          const moveX = Math.max(-maxMove, Math.min(maxMove, fx * damping));
          const moveY = Math.max(-maxMove, Math.min(maxMove, fy * damping));
          nodePositions[i].x += moveX;
          nodePositions[i].y += moveY;
        }
      }
      
      for (let pass = 0; pass < 50; pass++) {
        let hasOverlap = false;
        for (let i = 0; i < nodePositions.length; i++) {
          for (let j = i + 1; j < nodePositions.length; j++) {
            const dx = nodePositions[i].x - nodePositions[j].x;
            const dy = nodePositions[i].y - nodePositions[j].y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < minNodeDistance) {
              hasOverlap = true;
              const angle = dist < 0.1 ? Math.random() * 2 * Math.PI : Math.atan2(dy, dx);
              const separation = (minNodeDistance - dist) / 2;
              nodePositions[i].x += Math.cos(angle) * separation;
              nodePositions[i].y += Math.sin(angle) * separation;
              nodePositions[j].x -= Math.cos(angle) * separation;
              nodePositions[j].y -= Math.sin(angle) * separation;
            }
          }
        }
        if (!hasOverlap) break;
      }
      
      for (const pos of nodePositions) {
        nodes.push({ 
          id: pos.id, 
          label: String(pos.id), 
          x: Math.max(padding + 10, Math.min(svgWidth - padding - 10, pos.x)), 
          y: Math.max(padding + 10, Math.min(svgHeight - padding - 10, pos.y))
        });
      }
      
      for (let i = 0; i < nodes.length; i++) {
        for (let j = i + 1; j < nodes.length; j++) {
          const dx = nodes[i].x - nodes[j].x;
          const dy = nodes[i].y - nodes[j].y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < minNodeDistance * 0.8) {
            const angle = dist < 0.1 ? Math.random() * 2 * Math.PI : Math.atan2(dy, dx);
            const separation = (minNodeDistance * 0.8 - dist) / 2;
            nodes[i].x += Math.cos(angle) * separation;
            nodes[i].y += Math.sin(angle) * separation;
            nodes[j].x -= Math.cos(angle) * separation;
            nodes[j].y -= Math.sin(angle) * separation;
          }
        }
      }
      
      const sourceNode = 1;
      const visited = new Set([sourceNode]);
      const unvisited = new Set();
      for (let i = 2; i <= nodeCount; i++) {
        unvisited.add(i);
      }
      
      const randomWeight = () => Math.floor(Math.random() * 20) + 1;

      while (unvisited.size > 0) {
        const from = Array.from(visited)[Math.floor(Math.random() * visited.size)];
        const to = Array.from(unvisited)[Math.floor(Math.random() * unvisited.size)];
        const weight = randomWeight();
        const [minNode, maxNode] = from < to ? [from, to] : [to, from];
        const edgeId = `${minNode}-${maxNode}`;
        edges.push({ id: edgeId, from: minNode, to: maxNode, weight: weight });
        edgeSet.add(edgeId);
        visited.add(to);
        unvisited.delete(to);
      }
      
      const maxEdges = nodeCount * (nodeCount - 1) / 2;
      const remainingEdges = Math.min(edgeCount - edges.length, maxEdges - edges.length);
      
      for (let i = 0; i < remainingEdges; i++) {
        let attempts = 0;
        let from, to, edgeId;
        do {
          from = Math.floor(Math.random() * nodeCount) + 1;
          to = Math.floor(Math.random() * nodeCount) + 1;
          if (from === to) continue;
          const [minNode, maxNode] = from < to ? [from, to] : [to, from];
          edgeId = `${minNode}-${maxNode}`;
          attempts++;
          if (attempts > 100) break;
        } while (edgeSet.has(edgeId));
        
        if (attempts <= 100) {
          const weight = randomWeight();
          const [minNode, maxNode] = from < to ? [from, to] : [to, from];
          edges.push({ id: edgeId, from: minNode, to: maxNode, weight: weight });
          edgeSet.add(edgeId);
        }
      }
      
      return { nodes, edges };
    }

    /**
     * Generate all steps for Dial's algorithm with two-level bucket structure
     * 
     * Two-level bucket structure:
     * - Super buckets (blocks): Groups of buckets, block size = b
     * - Buckets: Individual buckets within each block
     * - Bucket index = distance % totalBuckets
     * - Block index = floor(distance / blockSize)
     * - Local bucket index = distance % blockSize
     * 
     * Algorithm steps:
     * 1. Initialize source node with distance 0
     * 2. While buckets are not empty:
     *    a. Find minimum non-empty bucket (scans blocks, then buckets)
     *    b. Extract node from min_bucket
     *    c. Mark node as settled
     *    d. Relax adjacent edges (Insert or DecreaseKey)
     * 3. All reachable nodes have shortest paths
     * 
     * @param {number} sourceNode - Starting node ID (typically 1)
     * @returns {Array} Array of step objects with block and bucket information
     */
    function generateDialSteps(sourceNode) {
      C = calculateC();
      totalBuckets = C + 1;
      const steps = [];
      let buckets = Array.from({ length: totalBuckets }, () => []);
      const distances = Object.fromEntries(graph.nodes.map((n) => [n.id, Infinity]));
      const settled = new Set();
      const nodeInBucket = new Set();
      
      function ensureBucketCapacity(requiredIndex) {
        if (requiredIndex > C) {
          const oldC = C;
          C = Math.max(C * 2, requiredIndex + 10);
          totalBuckets = C + 1;
          const newBuckets = Array.from({ length: totalBuckets }, () => []);
          for (let i = 0; i <= oldC; i++) {
            newBuckets[i] = buckets[i];
          }
          buckets = newBuckets;
        }
      }
      
      distances[sourceNode] = 0;
      const bucketIdx = 0 % totalBuckets;
      const blockIdx = Math.floor(0 / blockSize); // compute block index directly from distance
      const blockStart = blockIdx * blockSize; // block start in global bucket list = blockIdx √ó blockSize
      const localBucketIdx = 0 % blockSize; // local index inside the block = distance % blockSize
      buckets[bucketIdx].push(sourceNode);
      nodeInBucket.add(sourceNode);
      steps.push({
        action: `Insert(${sourceNode}, 0)`,
        type: 'insert',
        node: sourceNode,
        dist: 0,
        bucketIdx: bucketIdx,
        blockIdx: blockIdx,
        description: `Initialize source node ${sourceNode}, distance = 0. Bucket position: super bucket index ‚åä0 / ${blockSize}‚åã = ${blockIdx}, global bucket index 0 % ${totalBuckets} = ${bucketIdx}, block start = ${blockIdx} √ó ${blockSize} = ${blockStart}, local bucket = 0 % ${blockSize} = ${localBucketIdx}. Insert node ${sourceNode} into block ${blockIdx}, bucket ${localBucketIdx}.`
      });
      
      while (true) {
        let minBucket = -1;
        for (let i = 0; i < totalBuckets; i++) {
          if (buckets[i].length > 0) {
            minBucket = i;
            break;
          }
        }
        
        if (minBucket === -1) {
          break;
        }
        
        const currentNode = buckets[minBucket].shift();
        nodeInBucket.delete(currentNode);
        
        if (settled.has(currentNode)) {
          continue;
        }
        
        settled.add(currentNode);
        const currentNodeDist = distances[currentNode];
        const currentNodeBlockIdx = Math.floor(currentNodeDist / blockSize); // compute block index directly from distance
        const currentNodeBlockStart = currentNodeBlockIdx * blockSize;
        const currentNodeLocalBucketIdx = currentNodeDist % blockSize; // local index inside the block = distance % blockSize
        steps.push({
          action: `ExtractMin() -> ${currentNode}`,
          type: 'extract',
          node: currentNode,
          bucketIdx: minBucket,
          blockIdx: currentNodeBlockIdx,
          description: `Current min_bucket = ${minBucket} (block ${currentNodeBlockIdx}, bucket ${currentNodeLocalBucketIdx}). Extract node ${currentNode} from bucket ${currentNodeLocalBucketIdx} and mark it settled (shortest distance = ${currentNodeDist}).`
        });
        
        const adjacentEdges = graph.edges.filter((e) => 
          e.from === currentNode || e.to === currentNode
        );
        for (const edge of adjacentEdges) {
          const neighbor = edge.from === currentNode ? edge.to : edge.from;
          
          if (settled.has(neighbor)) {
            continue;
          }
          
          const newDist = distances[currentNode] + edge.weight;
          
          if (newDist > C) {
            ensureBucketCapacity(newDist);
          }
          
          if (distances[neighbor] === Infinity) {
            distances[neighbor] = newDist;
            const bucketIdx = newDist % totalBuckets;
            const blockIdx = Math.floor(newDist / blockSize); // compute block index directly from distance
            const blockStart = blockIdx * blockSize; // block start in global bucket list = blockIdx √ó blockSize
            const localBucketIdx = newDist % blockSize; // local index inside the block = distance % blockSize
            if (!buckets[bucketIdx].includes(neighbor)) {
              buckets[bucketIdx].push(neighbor);
              nodeInBucket.add(neighbor);
            }
            steps.push({
              action: `Insert(${neighbor}, ${newDist})`,
              type: 'insert',
              node: neighbor,
              dist: newDist,
              bucketIdx: bucketIdx,
              blockIdx: blockIdx,
              description: `Relax edge ${currentNode}‚Üí${neighbor} (weight ${edge.weight}); node ${neighbor} now has distance ${newDist}. Bucket placement: block index ‚åä${newDist} / ${blockSize}‚åã = ${blockIdx}, global bucket index ${newDist} % ${totalBuckets} = ${bucketIdx}, block start = ${blockIdx} √ó ${blockSize} = ${blockStart}, local bucket = ${newDist} % ${blockSize} = ${localBucketIdx}. Insert node ${neighbor} into block ${blockIdx}, bucket ${localBucketIdx}.`
            });
          } else if (newDist < distances[neighbor]) {
            const oldDist = distances[neighbor];
            const oldBucketIdx = oldDist % totalBuckets;
            const oldBlockIdx = Math.floor(oldDist / blockSize); // compute block index directly from distance
            const oldBlockStart = oldBlockIdx * blockSize;
            const oldLocalBucketIdx = oldDist % blockSize; // previous local index = distance % blockSize
            const oldBucketIdxInArray = buckets[oldBucketIdx].indexOf(neighbor);
            if (oldBucketIdxInArray !== -1) {
              buckets[oldBucketIdx].splice(oldBucketIdxInArray, 1);
              nodeInBucket.delete(neighbor);
            }
            distances[neighbor] = newDist;
            const bucketIdx = newDist % totalBuckets;
            const blockIdx = Math.floor(newDist / blockSize); // compute block index directly from distance
            const blockStart = blockIdx * blockSize; // block start in global bucket list = blockIdx √ó blockSize
            const localBucketIdx = newDist % blockSize; // new local index = distance % blockSize
            if (!buckets[bucketIdx].includes(neighbor)) {
              buckets[bucketIdx].push(neighbor);
              nodeInBucket.add(neighbor);
            }
            steps.push({
              action: `DecreaseKey(${neighbor}, ${oldDist} ‚Üí ${newDist})`,
              type: 'decrease',
              node: neighbor,
              oldDist: oldDist,
              newDist: newDist,
              oldBucketIdx: oldBucketIdx,
              oldBlockIdx: oldBlockIdx,
              bucketIdx: bucketIdx,
              blockIdx: blockIdx,
              description: `Relax edge ${currentNode}‚Üí${neighbor} (weight ${edge.weight}) and find a shorter path: distance ${oldDist} ‚Üí ${newDist}. Old location: block ${oldBlockIdx}, bucket ${oldLocalBucketIdx} (global bucket ${oldBucketIdx}). New placement: block index ‚åä${newDist} / ${blockSize}‚åã = ${blockIdx}, global bucket ${newDist} % ${totalBuckets} = ${bucketIdx}, block start = ${blockIdx} √ó ${blockSize} = ${blockStart}, local bucket = ${newDist} % ${blockSize} = ${localBucketIdx}. Move node ${neighbor} from block ${oldBlockIdx}, bucket ${oldLocalBucketIdx} to block ${blockIdx}, bucket ${localBucketIdx}.`
            });
          }
        }
      }
      
      steps.push({
        action: 'Algorithm complete',
        type: 'complete',
        description: `All reachable nodes now have finalized shortest paths. ${graph.nodes.filter(n => distances[n.id] !== Infinity).length} nodes are reachable.`
      });
      
      return steps;
    }

    // Algorithm state
    let steps = []; // Array of algorithm steps

    /**
     * Create the initial algorithm state
     * All nodes have infinite distance, no nodes are settled
     * 
     * @returns {Object} Initial state object
     */
    const initialState = () => ({
      buckets: Array.from({ length: totalBuckets }, () => []),
      nodeDistances: Object.fromEntries(graph.nodes.map((n) => [n.id, Infinity])),
      settled: [],
      focusNode: null,
      minBucket: null,
      focusBucketIdx: null,
      focusBlockIdx: null,
      description: 'Click "Next" to start simulating Dial two-level buckets.',
      action: 'Waiting to start'
    });

    let history = [];
    let superBucketElements = [];
    let bucketCellElements = {};
    let scanAnimationTimeouts = [];
    let postScanRenderTimeout = null;

    function deepCloneState(state) {
      return {
        buckets: state.buckets.map((bucket) => bucket.slice()),
        nodeDistances: { ...state.nodeDistances },
        settled: state.settled.slice(),
        focusNode: state.focusNode,
        minBucket: state.minBucket,
        focusBucketIdx: state.focusBucketIdx,
        focusBlockIdx: state.focusBlockIdx,
        description: state.description,
        action: state.action
      };
    }

    function findMinBucket(buckets) {
      for (let i = 0; i < buckets.length; i++) {
        if (buckets[i].length) return i;
      }
      return null;
    }

    function removeFromBucket(buckets, node) {
      for (let i = 0; i < buckets.length; i++) {
        const idx = buckets[i].indexOf(node);
        if (idx !== -1) {
          buckets[i].splice(idx, 1);
          return i;
        }
      }
      return null;
    }

    function applyStep(prevState, step) {
      const state = deepCloneState(prevState);

      if (step.type === 'insert') {
        const idx = step.bucketIdx !== undefined ? step.bucketIdx : (step.dist % totalBuckets);
        if (!state.buckets[idx].includes(step.node)) {
          state.buckets[idx].push(step.node);
        }
        state.nodeDistances[step.node] = step.dist;
        state.focusNode = step.node;
        // Store the bucket/block touched by this operation so the UI can auto-focus
        state.focusBucketIdx = idx;
        state.focusBlockIdx = step.blockIdx !== undefined ? step.blockIdx : Math.floor(idx / blockSize);
      } else if (step.type === 'decrease') {
        const oldIdx = step.oldBucketIdx !== undefined ? step.oldBucketIdx : (step.oldDist % totalBuckets);
        removeFromBucket(state.buckets, step.node);
        const idx = step.bucketIdx !== undefined ? step.bucketIdx : (step.newDist % totalBuckets);
        if (!state.buckets[idx].includes(step.node)) {
          state.buckets[idx].push(step.node);
        }
        state.nodeDistances[step.node] = step.newDist;
        state.focusNode = step.node;
        // Store the bucket/block touched by this operation
        state.focusBucketIdx = idx;
        state.focusBlockIdx = step.blockIdx !== undefined ? step.blockIdx : Math.floor(idx / blockSize);
      } else if (step.type === 'extract') {
        const idx = removeFromBucket(state.buckets, step.node);
        state.focusNode = step.node;
        if (!state.settled.includes(step.node)) {
          state.settled.push(step.node);
        }
        // During ExtractMin, derive focusBlockIdx from the minBucket
        if (step.blockIdx !== undefined) {
          state.focusBlockIdx = step.blockIdx;
        } else if (idx !== null) {
          state.focusBlockIdx = Math.floor(idx / blockSize);
        }
        state.focusBucketIdx = idx;
      } else if (step.type === 'complete') {
        state.focusNode = null;
        state.focusBucketIdx = null;
        state.focusBlockIdx = null;
      }

      state.minBucket = findMinBucket(state.buckets);
      state.description = step.description;
      state.action = step.action;
      return state;
    }

    function initializeAlgorithm() {
      clearScanAnimations();
      resetBucketHighlightClasses();
      steps = generateDialSteps(1);
      history = [initialState()];
      for (const step of steps) {
        const lastState = history[history.length - 1];
        history.push(applyStep(lastState, step));
      }
      currentIndex = 0;
      if (bucketTitle) {
        bucketTitle.textContent = `Two-Level Bucket Structure (C = ${C})`;
      }
    }

    let currentIndex = 0;

    const nodeElements = new Map();
    const edgeElements = new Map();

    function clearGraph() {
      const defs = svg.querySelector('defs');
      svg.innerHTML = '';
      if (defs) {
        svg.appendChild(defs);
      }
      nodeElements.clear();
      edgeElements.clear();
    }

    function renderGraph() {
      clearGraph();
      const edgesLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      edgesLayer.setAttribute('id', 'edgesLayer');
      const nodesLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      nodesLayer.setAttribute('id', 'nodesLayer');
      svg.appendChild(edgesLayer);
      svg.appendChild(nodesLayer);

      graph.edges.forEach((edge) => {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('stroke', '#94a3b8');
        line.setAttribute('stroke-width', '2');
        line.setAttribute('marker-end', 'url(#arrow)');

        const weightBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        weightBg.setAttribute('fill', '#ffffff');
        weightBg.setAttribute('stroke', '#475569');
        weightBg.setAttribute('stroke-width', '1');
        weightBg.setAttribute('rx', '3');
        weightBg.setAttribute('ry', '3');
        weightBg.setAttribute('opacity', '0.9');

        const weightText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        weightText.setAttribute('fill', '#1e293b');
        weightText.setAttribute('font-size', '14');
        weightText.setAttribute('font-weight', '700');
        weightText.setAttribute('text-anchor', 'middle');
        weightText.setAttribute('dominant-baseline', 'middle');
        weightText.textContent = edge.weight;

        edgesLayer.appendChild(line);
        edgesLayer.appendChild(weightBg);
        edgesLayer.appendChild(weightText);
        edgeElements.set(edge.id, { edge, line, weightText, weightBg });
      });

      graph.nodes.forEach((node) => {
        const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        group.classList.add('node');
        group.style.cursor = 'grab';

        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('r', 28);
        circle.setAttribute('stroke', '#0f172a');
        circle.setAttribute('stroke-width', '2');
        circle.setAttribute('fill', '#2563eb');

        const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        label.classList.add('node-label');
        label.setAttribute('text-anchor', 'middle');
        label.setAttribute('dominant-baseline', 'middle');
        label.setAttribute('fill', '#fff');
        label.setAttribute('font-size', '16');
        label.setAttribute('font-weight', '700');
        label.textContent = node.label;

        const distLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        distLabel.classList.add('dist-label');
        distLabel.setAttribute('text-anchor', 'middle');
        distLabel.textContent = 'dist = ‚àû';

        group.appendChild(circle);
        group.appendChild(label);
        group.appendChild(distLabel);
        nodesLayer.appendChild(group);

        enableDrag(group, node);
        nodeElements.set(node.id, { node, group, circle, label, distLabel });
      });

      updateGraphGeometry();
    }

    function enableDrag(group, node) {
      let dragging = false;
      let offsetX = 0;
      let offsetY = 0;

      group.addEventListener('pointerdown', (e) => {
        dragging = true;
        group.setPointerCapture(e.pointerId);
        const rect = svg.getBoundingClientRect();
        offsetX = e.clientX - rect.left - node.x;
        offsetY = e.clientY - rect.top - node.y;
        group.style.cursor = 'grabbing';
      });

      group.addEventListener('pointermove', (e) => {
        if (!dragging) return;
        const rect = svg.getBoundingClientRect();
        node.x = e.clientX - rect.left - offsetX;
        node.y = e.clientY - rect.top - offsetY;
        updateGraphGeometry();
      });

      const stop = (e) => {
        if (!dragging) return;
        dragging = false;
        group.releasePointerCapture(e.pointerId);
        group.style.cursor = 'grab';
      };

      group.addEventListener('pointerup', stop);
      group.addEventListener('pointerleave', stop);
    }

    function updateGraphGeometry() {
      const edgePositions = [];
      graph.edges.forEach((edge) => {
        const start = graph.nodes.find((n) => n.id === edge.from);
        const end = graph.nodes.find((n) => n.id === edge.to);
        const edgeData = edgeElements.get(edge.id);
        if (!edgeData) return;
        
        const dx = end.x - start.x;
        const dy = end.y - start.y;
        const edgeLength = Math.sqrt(dx * dx + dy * dy) || 1;
        const nodeRadius = 28;
        const minOffset = nodeRadius + 15;
        const offset = Math.max(minOffset, edgeLength * 0.15);
        const offsetRatio = Math.min(offset / edgeLength, 0.4);
        
        const weightStr = String(edge.weight);
        let charWidth = 9;
        if (weightStr.length === 1) {
          charWidth = 10;
        } else if (weightStr.length === 2) {
          charWidth = 9;
        } else {
          charWidth = 8.5;
        }
        const padding = 8;
        const textWidth = Math.max(weightStr.length * charWidth + padding, 24);
        const textHeight = 20;
        
        let midX = start.x + dx * (0.5 + offsetRatio * 0.1);
        let midY = start.y + dy * (0.5 + offsetRatio * 0.1);
        
        const perpX = -dy / edgeLength;
        const perpY = dx / edgeLength;
        
        edgePositions.push({
          edge,
          edgeData,
          start,
          end,
          dx,
          dy,
          edgeLength,
          midX,
          midY,
          perpX,
          perpY,
          textWidth,
          textHeight,
          weightStr
        });
      });
      
      for (let i = 0; i < edgePositions.length; i++) {
        const pos1 = edgePositions[i];
        let offset = 0;
        let attempts = 0;
        const maxAttempts = 10;
        
        while (attempts < maxAttempts) {
          let hasOverlap = false;
          const currentX = pos1.midX + pos1.perpX * offset;
          const currentY = pos1.midY + pos1.perpY * offset;
          
          for (let j = 0; j < edgePositions.length; j++) {
            if (i === j) continue;
            const pos2 = edgePositions[j];
            
            const distX = Math.abs(currentX - pos2.midX);
            const distY = Math.abs(currentY - pos2.midY);
            const minDistX = (pos1.textWidth + pos2.textWidth) / 2 + 5;
            const minDistY = (pos1.textHeight + pos2.textHeight) / 2 + 5;
            
            if (distX < minDistX && distY < minDistY) {
              hasOverlap = true;
              break;
            }
          }
          
          if (!hasOverlap) break;
          
          attempts++;
          offset = (attempts % 2 === 0 ? 1 : -1) * (attempts / 2 + 1) * 25;
        }
        
        pos1.finalX = pos1.midX + pos1.perpX * offset;
        pos1.finalY = pos1.midY + pos1.perpY * offset;
      }
      
      graph.edges.forEach((edge) => {
        const edgeData = edgeElements.get(edge.id);
        if (!edgeData) return;
        const { line, weightText, weightBg } = edgeData;
        
        const pos = edgePositions.find(p => p.edge.id === edge.id);
        if (!pos) return;
        
        const start = pos.start;
        const end = pos.end;
        
        line.setAttribute('x1', start.x);
        line.setAttribute('y1', start.y);
        line.setAttribute('x2', end.x);
        line.setAttribute('y2', end.y);
        
        weightText.setAttribute('x', pos.finalX);
        weightText.setAttribute('y', pos.finalY);
        weightText.textContent = pos.weightStr;
        
        if (weightBg) {
          weightBg.setAttribute('x', pos.finalX - pos.textWidth / 2);
          weightBg.setAttribute('y', pos.finalY - pos.textHeight / 2);
          weightBg.setAttribute('width', pos.textWidth);
          weightBg.setAttribute('height', pos.textHeight);
        }
      });

      nodeElements.forEach(({ node, circle, label, distLabel }) => {
        circle.setAttribute('cx', node.x);
        circle.setAttribute('cy', node.y);
        label.setAttribute('x', node.x);
        label.setAttribute('y', node.y);
        distLabel.setAttribute('x', node.x);
        distLabel.setAttribute('y', node.y + 40);
      });
    }

    /**
     * Render the super bucket (block) structure
     * Shows all blocks with their bucket ranges and status
     * Highlights the active block containing the current operation
     * 
     * @param {Object} state - Current algorithm state
     */
    function renderSuperBuckets(state) {
      superBucketContainer.innerHTML = '';
      superBucketElements = [];
      const totalBlocks = Math.ceil(totalBuckets / blockSize);
      for (let b = 0; b < totalBlocks; b++) {
        const start = b * blockSize;
        const end = Math.min(start + blockSize - 1, totalBuckets - 1);
        const bucketSlice = state.buckets.slice(start, end + 1);
        const hasNodes = bucketSlice.some((bucket) => bucket.length);
        const card = document.createElement('div');
        card.className = 'super-card';
        // Highlight the block involved in the current operation or the block that holds minBucket
        const shouldHighlight = (state.focusBlockIdx !== null && state.focusBlockIdx !== undefined && state.focusBlockIdx === b) ||
                                (state.minBucket !== null && Math.floor(state.minBucket / blockSize) === b);
        if (shouldHighlight) {
          card.classList.add('active');
        }
        const title = document.createElement('div');
        title.className = 'super-title';
        title.textContent = `Block ${b}`;

        const range = document.createElement('div');
        range.className = 'super-status super-range';
        range.textContent = `Buckets ${start} - ${end}`;

        const status = document.createElement('div');
        status.className = 'super-status';
        status.textContent = hasNodes ? 'Status: non-empty' : 'Status: empty';

        card.appendChild(title);
        card.appendChild(range);
        card.appendChild(status);

        card.addEventListener('click', () => {
          focusSuperIndex = b;
          renderBuckets(state);
          applyMinBucketVisualization(state, state.minBucket, { recentStep: null });
        });

        superBucketContainer.appendChild(card);
        superBucketElements[b] = card;
      }
    }

    let focusSuperIndex = 0;

    /**
     * Render the bucket detail view for the currently focused block
     * Shows individual buckets within the selected super bucket
     * Highlights the min_bucket and focus bucket
     * 
     * @param {Object} state - Current algorithm state
     * @param {Object} options - Rendering options (overrideBlock)
     */
    function renderBuckets(state, options = {}) {
      const { overrideBlock = null } = options;
      bucketCellElements = {};
      const totalBlocks = Math.ceil(totalBuckets / blockSize);
      // Prefer focusBlockIdx (block touched by the current action); otherwise fall back to the block that holds minBucket
      if (overrideBlock !== null && overrideBlock !== undefined) {
        focusSuperIndex = Math.min(Math.max(overrideBlock, 0), totalBlocks - 1);
      } else if (state.focusBlockIdx !== null && state.focusBlockIdx !== undefined) {
        focusSuperIndex = state.focusBlockIdx;
      } else if (minBucketMode === 'scan' && state.minBucket !== null) {
        focusSuperIndex = Math.floor(state.minBucket / blockSize);
      } else if (state.minBucket !== null) {
        focusSuperIndex = Math.floor(state.minBucket / blockSize);
      } else if (focusSuperIndex >= totalBlocks) {
        focusSuperIndex = 0;
      }

      const start = focusSuperIndex * blockSize;
      const end = Math.min(start + blockSize - 1, totalBuckets - 1);
      const localStart = 0;
      const localEnd = end - start;
      bucketDetailTitle.textContent = `Block ${focusSuperIndex}, buckets ${localStart} - ${localEnd}`;

      bucketGrid.innerHTML = '';
      for (let i = start; i <= end; i++) {
        const localBucketIdx = i - start; // local index within the block starting at 0
        const cell = document.createElement('div');
        cell.className = 'bucket-cell';
        const idx = document.createElement('div');
        idx.className = 'bucket-index';
        idx.textContent = `Bucket ${localBucketIdx}`;
        const content = document.createElement('div');
        content.className = 'bucket-content';
        content.textContent = state.buckets[i].length ? state.buckets[i].join(', ') : '‚àÖ';
        cell.appendChild(idx);
        cell.appendChild(content);
        bucketGrid.appendChild(cell);
        bucketCellElements[i] = cell;
      }
    }

    function clearScanAnimations() {
      scanAnimationTimeouts.forEach((id) => clearTimeout(id));
      scanAnimationTimeouts = [];
    }

    function resetBucketHighlightClasses() {
      superBucketElements.forEach((card) => {
        if (!card) return;
        card.classList.remove('scanning', 'scan-found', 'super-min');
      });
      Object.values(bucketCellElements).forEach((cell) => {
        if (!cell) return;
        cell.classList.remove('scanning', 'scan-found', 'min', 'focus');
      });
    }

    function highlightFocusBucket(state) {
      if (state.focusBucketIdx === null || state.focusBucketIdx === undefined) return;
      const cell = bucketCellElements[state.focusBucketIdx];
      if (cell) {
        cell.classList.add('focus');
      }
    }

    function highlightMinBucket(bucketIdx) {
      if (bucketIdx === null || bucketIdx === undefined) return;
      const cell = bucketCellElements[bucketIdx];
      if (cell) {
        cell.classList.add('min');
      }
      const blockIdx = Math.floor(bucketIdx / blockSize);
      const card = superBucketElements[blockIdx];
      if (card) {
        card.classList.add('super-min');
      }
    }

    function computeScanDelay(steps, budget) {
      if (!steps || steps <= 0) return SCAN_MIN_DELAY;
      const raw = Math.round(budget / steps);
      return Math.max(SCAN_MIN_DELAY, Math.min(SCAN_MAX_DELAY, raw));
    }

    function runSuperBucketScan(targetBlockIdx) {
      if (!superBucketElements.length) return 0;
      const clampedTarget = Math.max(0, Math.min(targetBlockIdx, superBucketElements.length - 1));
      const steps = clampedTarget + 1;
      const delay = computeScanDelay(steps, SUPER_SCAN_BUDGET);
      let elapsed = 0;
      for (let b = 0; b < steps; b++) {
        const card = superBucketElements[b];
        if (!card) {
          elapsed += delay;
          continue;
        }
        const enterId = setTimeout(() => {
          card.classList.add('scanning');
        }, elapsed);
        scanAnimationTimeouts.push(enterId);
        const exitId = setTimeout(() => {
          card.classList.remove('scanning');
          if (b === clampedTarget) {
            card.classList.add('scan-found', 'super-min');
          }
        }, elapsed + Math.max(40, delay - 40));
        scanAnimationTimeouts.push(exitId);
        elapsed += delay;
      }
      return steps * delay;
    }

    function runBucketCellScan(targetBucketIdx, startAfterMs) {
      const blockIdx = Math.floor(targetBucketIdx / blockSize);
      const blockStart = blockIdx * blockSize;
      const blockEnd = Math.min(blockStart + blockSize, totalBuckets);
      const entries = [];
      for (let i = blockStart; i < blockEnd; i++) {
        if (bucketCellElements[i]) {
          entries.push({ idx: i, element: bucketCellElements[i] });
        }
      }
      if (!entries.length) {
        return 0;
      }
      const targetPos = entries.findIndex((entry) => entry.idx === targetBucketIdx);
      if (targetPos === -1) {
        return 0;
      }
      const steps = targetPos + 1;
      const delay = computeScanDelay(steps, BUCKET_SCAN_BUDGET);
      for (let position = 0; position < steps; position++) {
        const entry = entries[position];
        const startTime = startAfterMs + delay * position;
        const enterId = setTimeout(() => {
          entry.element.classList.add('scanning');
        }, startTime);
        scanAnimationTimeouts.push(enterId);
        const exitId = setTimeout(() => {
          entry.element.classList.remove('scanning');
          if (entry.idx === targetBucketIdx) {
            entry.element.classList.add('scan-found', 'min');
          }
        }, startTime + Math.max(30, delay - 30));
        scanAnimationTimeouts.push(exitId);
      }
      return steps * delay;
    }

    function runTwoLevelScanVisualization(targetBucketIdx) {
      if (targetBucketIdx === null || targetBucketIdx === undefined) return 0;
      const targetBlockIdx = Math.floor(targetBucketIdx / blockSize);
      const superDuration = runSuperBucketScan(targetBlockIdx);
      const bucketDuration = runBucketCellScan(targetBucketIdx, superDuration);
      const totalDuration = superDuration + bucketDuration;
      const finalizeId = setTimeout(() => {
        highlightMinBucket(targetBucketIdx);
      }, totalDuration + 20);
      scanAnimationTimeouts.push(finalizeId);
      return totalDuration + 20;
    }

    function applyMinBucketVisualization(state, targetBucketIdx, options = {}) {
      const { shouldAnimate = false } = options;
      clearScanAnimations();
      resetBucketHighlightClasses();
      highlightFocusBucket(state);

      if (targetBucketIdx === null || targetBucketIdx === undefined) {
        return 0;
      }

      if (minBucketMode === 'scan' && shouldAnimate) {
        return runTwoLevelScanVisualization(targetBucketIdx);
      } else {
        highlightMinBucket(targetBucketIdx);
        return 0;
      }
    }

    function updateNodeStyles(state) {
      nodeElements.forEach(({ node, circle, distLabel }) => {
        const dist = state.nodeDistances[node.id];
        distLabel.textContent = Number.isFinite(dist) ? `dist = ${dist}` : 'dist = ‚àû';
        if (state.focusNode === node.id) {
          circle.setAttribute('fill', getColor('--accent-strong'));
          circle.setAttribute('stroke-width', '3');
        } else if (state.settled.includes(node.id)) {
          circle.setAttribute('fill', getColor('--success'));
          circle.setAttribute('stroke-width', '2');
        } else {
          circle.setAttribute('fill', getColor('--accent'));
          circle.setAttribute('stroke-width', '2');
        }
      });
    }

    function getColor(variable) {
      return getComputedStyle(document.documentElement).getPropertyValue(variable).trim();
    }

    function updateStatus(state) {
      const totalSteps = steps.length > 0 ? steps.length - 1 : 0;
      
      // Update the status panel details (mirrors DialBuckets.html format)
      if (stepCounterEl) {
        stepCounterEl.textContent = `Step ${currentIndex} / ${totalSteps}`;
      }
      
      if (currentActionEl) {
        currentActionEl.textContent = state.action || 'Waiting to start';
      }
      
      let descText = state.description || 'Click "Next" to start simulating Dial two-level buckets.';
      // When the algorithm finishes, display every reachable node distance
      if (steps.length > 0 && currentIndex === steps.length - 1 && steps[steps.length - 1].type === 'complete') {
        const distances = Object.entries(state.nodeDistances)
          .filter(([id, dist]) => Number.isFinite(dist))
          .sort(([a], [b]) => parseInt(a) - parseInt(b))
          .map(([id, dist]) => `Node ${id}: ${dist}`)
          .join(', ');
        if (distances) {
          descText += `\n\nShortest path results: ${distances}`;
        }
      }
      
      if (stepDescriptionEl) {
        stepDescriptionEl.textContent = descText;
      }
      
      if (minBucketLabelEl) {
        if (minBucketMode === 'scan') {
          minBucketLabelEl.textContent = 'Sequential scan mode: animate bucket traversal during ExtractMin().';
        } else {
          const hasMin = state.minBucket !== null && state.buckets[state.minBucket] && state.buckets[state.minBucket].length;
          minBucketLabelEl.textContent = hasMin
            ? `Current min_bucket = ${state.minBucket} (tracked)`
            : 'Current min_bucket = ‚àÖ (tracked)';
        }
      }
    }

    function updateProgress() {
      const progress = steps.length > 0 ? (currentIndex / (steps.length - 1)) * 100 : 0;
      progressBar.style.width = progress + '%';
    }

    function updateStats() {
      if (history.length === 0 || currentIndex >= history.length) return;
      const state = history[currentIndex];
      const settledCount = state.settled.length;
      const totalNodes = graph.nodes.length;
      const reachableNodes = Object.values(state.nodeDistances).filter(d => Number.isFinite(d)).length;
      
      statsInfo.innerHTML = `
        <div><strong>Settled nodes:</strong> ${settledCount} / ${totalNodes}</div>
        <div><strong>Reachable nodes:</strong> ${reachableNodes} / ${totalNodes}</div>
        <div><strong>Total steps:</strong> ${steps.length - 1}</div>
        <div><strong>Current step:</strong> ${currentIndex}</div>
      `;
    }

    function updateButtons() {
      prevBtn.disabled = currentIndex === 0;
      nextBtn.disabled = steps.length === 0 || currentIndex >= steps.length - 1;
    }

    /**
     * Render the complete visualization state
     * Updates graph, super buckets, buckets, node styles, and controls
     * Handles scan animations for sequential scan mode
     * This is the main rendering function called on each step
     */
    function renderState() {
      if (history.length === 0 || currentIndex >= history.length) {
        return;
      }
      const state = history[currentIndex];
      const recentStep = currentIndex > 0 ? steps[currentIndex - 1] : null;
      const previousState = currentIndex > 0 ? history[currentIndex - 1] : null;
      const shouldAnimateScan = minBucketMode === 'scan' && recentStep && recentStep.type === 'extract';
      const visualState = shouldAnimateScan && previousState ? previousState : state;
      const targetBucketIdx = shouldAnimateScan && recentStep && typeof recentStep.bucketIdx === 'number'
        ? recentStep.bucketIdx
        : visualState.minBucket;
      renderSuperBuckets(visualState);
      const blockOverride = shouldAnimateScan && targetBucketIdx !== null && targetBucketIdx !== undefined
        ? Math.floor(targetBucketIdx / blockSize)
        : null;
      renderBuckets(visualState, { overrideBlock: blockOverride });
      const animationDuration = applyMinBucketVisualization(visualState, targetBucketIdx, { shouldAnimate: shouldAnimateScan });
      updateNodeStyles(state);
      updateStatus(state);
      updateButtons();
      updateProgress();
      updateStats();

      if (postScanRenderTimeout) {
        clearTimeout(postScanRenderTimeout);
        postScanRenderTimeout = null;
      }
      if (shouldAnimateScan && visualState !== state) {
        postScanRenderTimeout = setTimeout(() => {
          renderSuperBuckets(state);
          renderBuckets(state);
          applyMinBucketVisualization(state, state.minBucket, { shouldAnimate: false });
        }, animationDuration + 30);
      }
    }

    // Auto-play state management
    let isPlaying = false; // Whether algorithm is currently auto-playing
    let playInterval = null; // Interval ID for auto-play timer

    /**
     * Toggle auto-play mode
     * When playing, advances steps automatically at the configured speed
     * When paused, stops automatic advancement
     */
    function togglePlay() {
      if (isPlaying) {
        if (playInterval) {
          clearInterval(playInterval);
          playInterval = null;
        }
        isPlaying = false;
        playPauseBtn.textContent = '‚ñ∂ Play';
        playPauseBtn.classList.remove('playing');
      } else {
        if (currentIndex >= steps.length - 1) {
          currentIndex = 0;
        }
        isPlaying = true;
        playPauseBtn.textContent = '‚è∏ Pause';
        playPauseBtn.classList.add('playing');
        
        const speed = parseInt(speedSlider.value);
        playInterval = setInterval(() => {
          if (currentIndex >= steps.length - 1) {
            togglePlay();
            return;
          }
          currentIndex += 1;
          renderState();
        }, speed);
      }
    }

    speedSlider.addEventListener('input', (e) => {
      const speed = parseInt(e.target.value);
      speedValue.textContent = (speed / 1000).toFixed(1) + 's';
      if (isPlaying) {
        togglePlay();
        togglePlay();
      }
    });

    prevBtn.addEventListener('click', () => {
      if (isPlaying) togglePlay();
      if (currentIndex === 0) return;
      currentIndex -= 1;
      renderState();
    });

    nextBtn.addEventListener('click', () => {
      if (isPlaying) togglePlay();
      if (currentIndex >= steps.length - 1) return;
      currentIndex += 1;
      renderState();
    });

    resetBtn.addEventListener('click', () => {
      if (isPlaying) togglePlay();
      currentIndex = 0;
      focusSuperIndex = 0;
      renderState();
    });

    playPauseBtn.addEventListener('click', togglePlay);

    if (minBucketModeSelect) {
      minBucketModeSelect.addEventListener('change', (event) => {
        minBucketMode = event.target.value;
        renderState();
      });
    }

    blockSizeRange.addEventListener('input', () => {
      blockSize = Number(blockSizeRange.value);
      blockSizeValue.textContent = blockSize;
      if (isPlaying) {
        togglePlay();
      }
      initializeAlgorithm();
      renderState();
    });

    generateGraphBtn.addEventListener('click', () => {
      const nodeCount = parseInt(nodeCountInput.value) || 7;
      const edgeCount = parseInt(edgeCountInput.value) || 11;
      
      if (nodeCount < 2 || nodeCount > 15) {
        alert('Node count must be between 2 and 15.');
        return;
      }
      
      const maxEdges = nodeCount * (nodeCount - 1) / 2;
      const minEdges = nodeCount - 1;
      if (edgeCount < minEdges || edgeCount > maxEdges) {
        alert(`Edge count must be between ${minEdges} and ${maxEdges}.`);
        return;
      }
      
      if (isPlaying) togglePlay();
      
      graph = generateRandomGraph(nodeCount, edgeCount);
      renderGraph();
      updateGraphGeometry();
      initializeAlgorithm();
      renderState();
    });

    // Initialize the application
    // Generate algorithm steps, render the graph, and display initial state
    initializeAlgorithm();
    renderGraph();
    updateGraphGeometry();
    renderState();
  </script>
</body>
</html>

